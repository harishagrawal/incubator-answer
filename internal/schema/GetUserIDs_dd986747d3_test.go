/*
Test generated by RoostGPT for test go-unit using AI Type Azure Open AI and AI Model roostgpt-4-32k

1. Scenario: Calling GetUserIDs on an AcceptAnswerOperationInfo object where all ActivityUserID fields are populated. The function should return a list of all unique ActivityUserID values.

2. Scenario: Calling GetUserIDs on an AcceptAnswerOperationInfo object where some Activities do not have an ActivityUserID. The function should return a list of all the unique ActivityUserID values for the Activities where it is set, ignoring those where it is not set.

3. Scenario: Calling GetUserIDs on an AcceptAnswerOperationInfo object with no Activities at all. The function should return an empty slice.

4. Scenario: Calling GetUserIDs on an AcceptAnswerOperationInfo object where all Activities have an ActivityUserID, but they're all the same. Function should return a slice that only contains that single UserID once.

5. Scenario: Calling GetUserIDs on an AcceptAnswerOperationInfo object where Activities array contains nil elements. The function should ignore the nil elements and only append non-nil ActivityUserID.

6. Scenario: Calling GetUserIDs on an AcceptAnswerOperationInfo object where Activities array contains duplicate ActivityUserID but with different case(i.e., "UserID1", "userid1"). The function should be case sensitive and return both UserIDs separately.

7. Scenario: Calling GetUserIDs on an AcceptAnswerOperationInfo object where the length of Activities array is very large. The function should be able to handle such a scenario without issue.

8. Scenario: Verify that GetUserIDs on an AcceptAnswerOperationInfo object always returns a slice, even if AcceptAnswerOperationInfo is nil or Activities slice is nil.

9. Scenario: Calling GetUserIDs on an AcceptAnswerOperationInfo object where all Activities have an ActivityUserID and they're all different. The function should return a slice that contains all UserIDs in the order they were in the Activities slice.
*/
package schema

import (
	"reflect"
	"testing"
)

func TestGetUserIDs_dd986747d3(t *testing.T) {
	// test data
	activities := []*AcceptAnswerActivity{
		{ActivityUserID: "user1"},
		{ActivityUserID: "user2"},
		{ActivityUserID: "user3"},
		{ActivityUserID: ""},
		{ActivityUserID: "user5"},
		nil,
		{ActivityUserID: "user6"},
		{ActivityUserID: "user1"},
		{ActivityUserID: "USER1"},
	}

	testCases := []struct {
		name       string
		activities []*AcceptAnswerActivity
		expected   []string
	}{
		{"All UIDs populated", activities[:3], []string{"user1", "user2", "user3"}},
		{"Some UIDs missing", activities[:5], []string{"user1", "user2", "user3", "user5"}},
		{"No activities", []*AcceptAnswerActivity{}, []string{}},
		{"All same UIDs", []*AcceptAnswerActivity{{ActivityUserID: "user1"}, {ActivityUserID: "user1"}}, []string{"user1"}},
		{"Contains nil elements", []*AcceptAnswerActivity{{ActivityUserID: "user2"}, nil, {ActivityUserID: "user3"}}, []string{"user2", "user3"}},
		{"Case sensitive duplicates", []*AcceptAnswerActivity{{ActivityUserID: "user1"}, {ActivityUserID: "USER1"}}, []string{"user1", "USER1"}},
		{"Large number of activities", activities, []string{"user1", "user2", "user3", "user5", "user6", "user1", "USER1"}},
		{"Nil OperationInfo or nil Activities", nil, []string{}},
		{"All different UIDs", activities[:6], []string{"user1", "user2", "user3", "", "user5"}},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			op := &AcceptAnswerOperationInfo{Activities: tc.activities}
			got := op.GetUserIDs()
			if !reflect.DeepEqual(tc.expected, got) {
				t.Fatalf("Failed on %s, Expected: %v, But Got: %v", tc.name, tc.expected, got)
			} else {
				t.Logf("Success on %s", tc.name)
			}
		})
	}
}
